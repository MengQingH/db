# 锁的基本概念
当**并发事务同时访问一个资源**时，有可能导致数据不一致，因此需要一种机制来将访问顺序化，以保证数据库数据的一致性。

# 锁的基本类型
数据库的操作可以归纳为两种：读和写。多个事务同时读取一个对象的时候，是不会有冲突的，同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：共享锁和排他锁。执行sql： select * from information_schema.innodb_locks; 可以查看锁。
## 共享锁
共享锁(S)表示对数据进行读操作。因此多个事务可以同时为一个对象加共享锁。
产生共享锁的sql：select * from ad_plan lock in share mode;
## 排他锁
排他锁也叫写锁(X)。
排他锁表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。
产生排他锁的sql： select * from ad_plan for update;

## 锁的粒度
MySQL有三种锁级别：行级、叶级、表级。不同的存储引擎支持不同的锁机制。MySIAM和MEMORY存储引擎使用的是表级锁，InnoDB既支持表级锁，也支持行级锁，默认情况下采用行级锁。
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页级锁：开销和加锁时间介于表锁和行锁之间，会出现死锁；锁定粒度和并发度处于表锁和行锁之间。

## 行锁
对一行数据加锁，只影响一条记录。通常用在DML语句中，如insert、update、delete等。InnoDB行锁是通过给索引上的索引项加锁来实现的，这就意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则将使用表锁。
## 表锁
对整个表加锁，影响标准的所有记录，通常用在DDL语句中，如DELETE TABLE,ALTER TABLE等。表锁影响整个表的数据，因此并发性不如行锁好。在MySQL 数据库中，使用表级锁定的主要是MyISAM，Memory等一些非事务性存储引擎。




# 悲观锁和乐观锁
悲观锁和乐观锁是两种常见的资源并发锁设计思路。
## 悲观锁
悲观锁的特点是先获取锁，再进行业务操作，即悲观的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。通常来讲，数据库上实现悲观锁需要数据库提供支持，即通过常用的select···for upadate实现悲观锁。当数据库执行select···for update时会获取被select中的数据行的行锁，其他并发执行的select···for update如果视图选中同一行会发生排斥，因此达到锁的效果。
```sql
--开启事务
select id, total, front, end from price where id=1 for update 
insert into price values(?,?,?,?,?)

commit --提交事务
```
上面的sql语句使用了select for update的方式开启了悲观锁，锁定了id=1这条数据
## 乐观锁
乐观锁的特点是先进行业务操作，最后实际更新数据时检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持，一般的做法是在需要锁的数据上加上一个版本号或时间戳，然后按如下方式实现：
```sql
select data as old_data,version as old_version from table;
update table set data = new_data,version = new_version where version=old_version;


if(updated row=0){
    //乐观锁获取成功，操作完成
}else{
    //乐观锁获取失败，回滚并重试
}
```
## 应用场景
一般情况下，读取频繁适合用乐观锁，写入频繁更适合用悲观锁。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。
